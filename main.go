package main

import (
	"context"
	"encoding/json"
	"time"

	"github.com/eduardolat/openroutergo"
)

var (
	apiKey = ""
	model  = "anthropic/claude-3.7-sonnet"
)

type GetNamesResponse struct {
	Names []string `json:"names"`
}

type SentimentAnalysisResponse struct {
	Sentiment string  `json:"sentiment"`
	Score     float64 `json:"score"`
}

func main() {
	ctx, cancelCtx := context.WithTimeout(context.Background(), 120*time.Second)
	defer cancelCtx()

	log := NewLogger()

	client, err := openroutergo.
		NewClient().
		WithAPIKey(apiKey).
		Create()
	if err != nil {
		log.Error("initiating client", "err", err)
		return
	}

	completion := client.NewChatCompletion().
		WithContext(ctx).
		WithModel(model).
		WithTool(openroutergo.ChatCompletionTool{
			Name:        "getNames",
			Description: "Get all the names provided by the user before generating a response, use this when the user mentions anyone by name.",
			Parameters: map[string]any{
				"type": "object",
				"properties": map[string]any{
					"names": map[string]any{
						"type": "array",
						"items": map[string]any{
							"type": "string",
						},
					},
				},
				"required": []string{"names"},
			},
		}).
		WithTool(openroutergo.ChatCompletionTool{
			Name:        "analyzeSentiment",
			Description: "Analyze the sentiment of the response generated",
			Parameters: map[string]any{
				"type": "object",
				"properties": map[string]any{
					"sentiment": map[string]any{
						"type":        "string",
						"enum":        []string{"positive", "neutral", "negative"},
						"description": "The overall sentiment of the response",
					},
					"score": map[string]any{
						"type":        "number",
						"minimum":     0,
						"maximum":     1,
						"description": "Confidence score (0-1) for the sentiment analysis",
					},
				},
				"required": []string{"sentiment", "score"},
			},
		}).
		WithSystemMessage("Always reply in plain text in a single line. At the end run a sentiment analysis for the response generated by the model.")

	content := "Write me a two-sentence rhyme for my friends Eric and Jozef. Don't forget to include Martin too!"
	log.User(content)

	message := openroutergo.ChatCompletionMessage{
		Role:    openroutergo.RoleUser,
		Content: content,
	}

	startTime := time.Now()
	cycleCount := 1
	for {
		_, resp, err := completion.
			WithMessage(message).
			Execute()
		if err != nil {
			log.Error("executing completion", "duration", time.Since(startTime), "err", err)
			return
		}
		if !resp.HasChoices() {
			log.Error("No choices in response", "duration", time.Since(startTime), "resp", resp)
			break
		}

		log.System("completion executed", "cycleCount", cycleCount, "duration", time.Since(startTime), "usage", resp.Usage)

		for _, choice := range resp.Choices {
			if choice.Message.Content == "" {
				continue
			}
			switch role := choice.Message.Role; role {
			case openroutergo.RoleAssistant:
				log.Agent(choice.Message.Content)
			}
		}

		shouldContinue := false
		draftMessage := openroutergo.ChatCompletionMessage{
			Role: openroutergo.RoleTool,
		}

		for _, choice := range resp.Choices {
			if choice.Message.HasToolCalls() {
				tools := choice.Message.ToolCalls
				for _, tool := range tools {
					switch toolName := tool.Function.Name; toolName {
					case "getNames":
						toolArguments := tool.Function.Arguments
						var names GetNamesResponse
						if err := json.Unmarshal([]byte(toolArguments), &names); err != nil {
							log.Error("Failed to unmarshal names response", "duration", time.Since(startTime), "err", err)
							break
						}
						log.System("Ran tool", "duration", time.Since(startTime), "toolName", toolName, "names", names)

						draftMessage.ToolCallID, draftMessage.Name, draftMessage.Content = tool.ID, toolName, toolArguments
						shouldContinue = true
					case "analyzeSentiment":
						toolArguments := tool.Function.Arguments
						var sentiment SentimentAnalysisResponse
						if err := json.Unmarshal([]byte(toolArguments), &sentiment); err != nil {
							log.Error("Failed to unmarshal sentiment response", "duration", time.Since(startTime), "err", err)
							break
						}
						log.System("Ran tool", "duration", time.Since(startTime), "toolName", toolName, "sentiment", sentiment)

						draftMessage.ToolCallID, draftMessage.Name, draftMessage.Content = tool.ID, toolName, toolArguments
						shouldContinue = true
					}
				}
			}
		}

		if !shouldContinue {
			log.System("No tool results", "duration", time.Since(startTime))
			break
		}

		message = draftMessage
		cycleCount++
	}
}
