package main

import (
	"context"
	"encoding/json"
	"time"

	"github.com/eduardolat/openroutergo"
)

func main() {
	log := NewLogger()
	cfg, err := NewConfig()
	if err != nil {
		log.Error("loading config", "err", err)
		return
	}

	client, err := openroutergo.
		NewClient().
		WithAPIKey(cfg.OpenRouterAPIKey).
		Create()
	if err != nil {
		log.Error("initiating client", "err", err)
		return
	}

	systemPrompt := "Always reply in plain text in a single line. At the end run a sentiment analysis for the response generated by the model."

	baseCompletion := client.NewChatCompletion().
		WithContext(context.Background()).
		WithModel(cfg.Model).
		WithModelFallback(cfg.ModelFallback).
		WithTool(PrintEntitiesTool).
		WithTool(AnalyzeSentimentTool).
		WithSystemMessage(systemPrompt)

	content := "Write me a short and concise rhyme about Jozef who works at Webscope. He met with his colleague and friend Eric, last week at Zenwork office in Prague."
	log.User(content)

	message := openroutergo.ChatCompletionMessage{
		Role:    openroutergo.RoleUser,
		Content: content,
	}

	startTime := time.Now()
	cycleCount := 1

	for {
		_, resp, err := baseCompletion.
			WithMessage(message).
			Execute()
		if err != nil {
			log.Error("Executing completion", "duration", time.Since(startTime), "err", err)
			return
		}
		if !resp.HasChoices() {
			log.Error("No choices in response", "duration", time.Since(startTime), "resp", resp)
			break
		}

		log.System("Completion executed", "cycleCount", cycleCount, "duration", time.Since(startTime), "usage", resp.Usage)

		for _, choice := range resp.Choices {
			if choice.Message.Content == "" {
				continue
			}
			switch role := choice.Message.Role; role {
			case openroutergo.RoleAssistant:
				log.Agent(choice.Message.Content)
			}
		}

		shouldContinue := false
		var inputs any
		draftMessage := openroutergo.ChatCompletionMessage{
			Role: openroutergo.RoleTool,
		}

		for _, choice := range resp.Choices {
			if choice.Message.HasToolCalls() {
				tools := choice.Message.ToolCalls
				for _, tool := range tools {
					switch toolName := tool.Function.Name; toolName {
					case PrintEntitiesTool.Name:
						toolArguments := tool.Function.Arguments
						var entities EntitiesInput
						if err := json.Unmarshal([]byte(toolArguments), &entities); err != nil {
							log.Error("Unmarshal entities input", "duration", time.Since(startTime), "err", err)
							break
						}
						shouldContinue, inputs = true, entities
						draftMessage.ToolCallID, draftMessage.Name, draftMessage.Content = tool.ID, toolName, toolArguments
					case AnalyzeSentimentTool.Name:
						toolArguments := tool.Function.Arguments
						var sentiment SentimentAnalysisInput
						if err := json.Unmarshal([]byte(toolArguments), &sentiment); err != nil {
							log.Error("Unmarshal sentiment input", "duration", time.Since(startTime), "err", err)
							break
						}
						shouldContinue, inputs = true, sentiment
						draftMessage.ToolCallID, draftMessage.Name, draftMessage.Content = tool.ID, toolName, toolArguments
					}
				}
			}
		}

		if !shouldContinue {
			log.System("No tool results, exiting...", "duration", time.Since(startTime))
			break
		}

		log.System("Tool executed", "duration", time.Since(startTime), "toolName", draftMessage.Name, "inputs", inputs)
		message = draftMessage
		cycleCount++
	}
}
